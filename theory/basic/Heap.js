//* Heap : 특정한 규칙을 가지는 트리로, 힙을 이용해 우선순위 큐를 구현

// 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리(complete binary tree)를 기본으로 한 자료구조(tree-based structure)
// A가 B의 부모노드(parent node) 이면, A의 키(key)값과 B의 키값 사이에는 대소관계가 성립한다
// 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 '최대 힙', 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 '최소 힙'
// 우선순위를 가진 노드 즉 부모노드가 항상 뿌리에 오게 하는 특징.

// 대부분의 경우는 자식노드의 개수가 최대 2개인 이진 힙(binary heap)

// javscript

// 1번 작업중       [4 5 8 2 3]  => 우선순위를 결정하는것이 heap

// 우선순위 작업

// 중요도가 높은것이 상단으로
// 8
// 5       4
// 3  2
// [8, 5, 4, 3, 2]

//? 문제 : 디스크 컨트롤러

// [[0, 3], [1, 9], [2, 6]] : 해야될 작업들
// [시작시점, 작업시간]
// 작업별 평균소요 시간이 가장 작은것을 return

//  [0, 3] 이후 [1, 9] 먼저하면
// 0초부터 3초 흐른 시점에 작업 종료
// (0초 요청부터 3초 종료까지 3ms)
// 1번째 작업이 종료되는 3초부터 9초가 흐린 12초 시점에 2번째 작업종료
// (1초에 요청부터 12초 종료까지 11ms)
// 2번째 작업이 종료되는 12초부터 6초가 흐른 18초 시점에 3번째 작업 종료
// (2초 요청부터 18초 종료까지 16ms)
// 평균 : (3+11+16)/ 3 = 10ms

//  [0, 3] 이후 [2, 6] 먼저하면
// 0초부터 3초 흐른 시점에 작업 종료
// (0초 요청부터 3초 종료까지 3ms)
// 1번째 작업이 종료되는 3초부터 6초가 흐린 9초 시점에 2번째 작업종료
// (2초에 요청부터 9초 종료까지 7ms)
// 2번째 작업이 종료되는 9초부터 9초가 흐른 18초 시점에 3번째 작업 종료
// (1초 요청부터 18초 종료까지 17ms)
// 평균 : (3+7+17)/ 3 = 9ms

// 9

const diskController = (arr) => {
	arr.sort((a, b) => {
		return a[0] - b[0];
	});

	console.log(arr);

	let sec = 0;
	// sec ++ 시간 흐르게 하면서 하나씩 처리
	// 1번째 작업 동안 시작되는것을 대기 목록에 넣는다.
	// 1번째 작업이 끝나면 요청 시점부터 종료시점의 차이를 기록.
};

// console.log(
// 	diskController([
// 		[0, 3],
// 		[1, 9],
// 		[2, 6],
// 	])
// ); // 9

// console.log(
// 	diskController([
// 		[0, 3],
// 		[2, 6],
// 		[1, 9],
// 	])
// ); // 9

// console.log(
// 	diskController([
// 		[0, 5],
// 		[2, 6],
// 		[1, 4],
// 		[3, 7],
// 	])
// ); // 9
